package syncman

import (
	"context"
	"errors"

	"github.com/stretchr/testify/mock"

	"github.com/spaceuptech/space-cloud/gateway/config"
	"github.com/spaceuptech/space-cloud/gateway/model"
	"github.com/spaceuptech/space-cloud/gateway/modules/global/letsencrypt"
	"github.com/spaceuptech/space-cloud/gateway/modules/global/routing"
)

type mockIntegrationManager struct {
	mock.Mock
	skip bool
}

func (m *mockIntegrationManager) SetConfig(array config.Integrations) error {
	return m.Called(array).Error(0)
}

func (m *mockIntegrationManager) InvokeHook(_ context.Context, params model.RequestParams) config.IntegrationAuthResponse {
	if m.skip {
		return mockHookResponse{checkResponse: false}
	}
	return m.Called(params).Get(0).(config.IntegrationAuthResponse)
}

type mockHookResponse struct {
	checkResponse bool
	err           string
	result        interface{}
	status        int
}

// CheckResponse indicates whether the integration is hijacking the authentication of the request or not.
// Its a humble way of saying that I'm the boss for this request
func (r mockHookResponse) CheckResponse() bool {
	return r.checkResponse
}

// Error returns error generated by the module if CheckResponse() returns true.
func (r mockHookResponse) Error() error {
	if r.err == "" {
		return nil
	}
	return errors.New(r.err)
}

// Result returns the value received from the integration
func (r mockHookResponse) Result() interface{} {
	return r.result
}

// Status returns the status code received from the integration
func (r mockHookResponse) Status() int {
	return r.status
}

type mockAdminSyncmanInterface struct {
	mock.Mock
}

func (m *mockAdminSyncmanInterface) ValidateIntegrationSyncOperation(integrations config.Integrations) error {
	return m.Called(integrations).Error(0)
}

func (m *mockAdminSyncmanInterface) ParseLicense(license string) (map[string]interface{}, error) {
	v := m.Called(license)
	return v.Get(0).(map[string]interface{}), v.Error(1)
}

func (m *mockAdminSyncmanInterface) GetIntegrationToken(id string) (string, error) {
	v := m.Called(id)
	return v.String(0), v.Error(1)
}

func (m *mockAdminSyncmanInterface) IsRegistered() bool {
	return m.Called().Bool(0)
}

func (m *mockAdminSyncmanInterface) GetSessionID() string {
	return m.Called().String(0)
}

func (m *mockAdminSyncmanInterface) RenewLicense(b bool) error {
	return m.Called(b).Error(0)
}

func (m *mockAdminSyncmanInterface) ValidateProjectSyncOperation(projects *config.Config, projectID *config.Project) bool {
	return m.Called(projects, projectID).Bool(0)
}

func (m *mockAdminSyncmanInterface) SetConfig(admin *config.Admin, isFirst bool) error {
	return m.Called(admin, isFirst).Error(0)
}

func (m *mockAdminSyncmanInterface) IsTokenValid(_ context.Context, token, resource, op string, attr map[string]string) (model.RequestParams, error) {
	c := m.Called(token, resource, op, attr)
	return c.Get(0).(model.RequestParams), c.Error(1)
}

func (m *mockAdminSyncmanInterface) GetInternalAccessToken() (string, error) {
	c := m.Called()
	return c.String(0), c.Error(1)
}

func (m *mockAdminSyncmanInterface) GetConfig() *config.Admin {
	return m.Called().Get(0).(*config.Admin)
}

type mockModulesInterface struct {
	mock.Mock
}

func (m *mockModulesInterface) LetsEncrypt() *letsencrypt.LetsEncrypt {
	return m.Called().Get(0).(*letsencrypt.LetsEncrypt)
}

func (m *mockModulesInterface) Routing() *routing.Routing {
	return m.Called().Get(0).(*routing.Routing)
}

func (m *mockModulesInterface) Delete(projectID string) {
	m.Called(projectID)
}

func (m *mockModulesInterface) SetProjectConfig(config *config.Project) error {
	return m.Called(config).Error(0)
}

func (m *mockModulesInterface) SetGlobalConfig(projectID, secretSource string, secrets []*config.Secret, aesKey string) error {
	c := m.Called(projectID, secrets, aesKey)
	return c.Error(0)
}

func (m *mockModulesInterface) SetCrudConfig(projectID string, crudConfig config.Crud) error {
	c := m.Called(projectID, crudConfig)
	return c.Error(0)
}

func (m *mockModulesInterface) SetServicesConfig(projectID string, services *config.ServicesModule) error {
	c := m.Called(projectID, services)
	return c.Error(0)
}

func (m *mockModulesInterface) SetFileStoreConfig(projectID string, fileStore *config.FileStore) error {
	c := m.Called(projectID, fileStore)
	return c.Error(0)
}

func (m *mockModulesInterface) SetEventingConfig(projectID string, eventingConfig *config.Eventing) error {
	c := m.Called(projectID, eventingConfig)
	return c.Error(0)
}

func (m *mockModulesInterface) SetUsermanConfig(projectID string, auth config.Auth) error {
	return m.Called(projectID, auth).Error(0)
}

func (m *mockModulesInterface) GetSchemaModuleForSyncMan(projectID string) (model.SchemaEventingInterface, error) {
	c := m.Called(projectID)
	return c.Get(0).(model.SchemaEventingInterface), c.Error(1)
}

func (m *mockModulesInterface) GetAuthModuleForSyncMan(projectID string) (model.AuthSyncManInterface, error) {
	c := m.Called(projectID)
	return c.Get(0).(model.AuthSyncManInterface), c.Error(1)
}

type mockStoreInterface struct {
	mock.Mock
}

func (m *mockStoreInterface) WatchProjects(cb func(projects []*config.Project)) error {
	c := m.Called(cb)
	return c.Error(0)
}

func (m *mockStoreInterface) WatchServices(cb func(projects scServices)) error {
	c := m.Called(cb)
	return c.Error(0)
}

func (m *mockStoreInterface) Register() {
	m.Called()
}

func (m *mockStoreInterface) SetProject(ctx context.Context, project *config.Project) error {
	c := m.Called(ctx, project)
	return c.Error(0)
}

func (m *mockStoreInterface) DeleteProject(ctx context.Context, projectID string) error {
	c := m.Called(ctx, projectID)
	return c.Error(0)
}

func (m *mockStoreInterface) SetAdminConfig(ctx context.Context, adminConfig *config.Admin) error {
	c := m.Called(ctx, adminConfig)
	return c.Error(0)
}

func (m *mockStoreInterface) GetAdminConfig(ctx context.Context) (*config.Admin, error) {
	c := m.Called(ctx)
	return c.Get(0).(*config.Admin), c.Error(1)
}

func (m *mockStoreInterface) WatchAdminConfig(cb func(clusters []*config.Admin)) error {
	c := m.Called(cb)
	return c.Error(0)
}

type mockSchemaEventingInterface struct {
	mock.Mock
}

func (m *mockSchemaEventingInterface) CheckIfEventingIsPossible(dbAlias, col string, obj map[string]interface{}, isFind bool) (findForUpdate map[string]interface{}, present bool) {
	c := m.Called(dbAlias, col, obj, isFind)
	return map[string]interface{}{}, c.Bool(1)
}

func (m *mockSchemaEventingInterface) Parser(crud config.Crud) (model.Type, error) {
	c := m.Called(crud)
	return nil, c.Error(1)
}

func (m *mockSchemaEventingInterface) SchemaValidator(ctx context.Context, col string, collectionFields model.Fields, doc map[string]interface{}) (map[string]interface{}, error) {
	c := m.Called(col, collectionFields, doc)
	return nil, c.Error(1)
}

func (m *mockSchemaEventingInterface) SchemaModifyAll(ctx context.Context, dbAlias, logicalDBName string, tables map[string]*config.TableRule) error {
	c := m.Called(ctx, dbAlias, logicalDBName, tables)
	return c.Error(0)
}

func (m *mockSchemaEventingInterface) SchemaInspection(ctx context.Context, dbAlias, project, col string) (string, error) {
	c := m.Called(ctx, dbAlias, project, col)
	return c.String(0), c.Error(1)
}

func (m *mockSchemaEventingInterface) GetSchema(dbAlias, col string) (model.Fields, bool) {
	c := m.Called(dbAlias, col)
	return c.Get(0).(model.Fields), c.Bool(1)
}
